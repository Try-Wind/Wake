use async_trait::async_trait;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use wake_llm::tools::{Tool, ToolArguments, ToolCall, ToolResult};
use wake_macros::tool_derive;

#[tool_derive]
#[derive(Clone, Debug, Serialize, Deserialize, JsonSchema)]
pub struct DriverGeneratorArgs {
    /// The hardware component or chip name (e.g., "MPU6050", "BMP280", "SSD1306")
    pub component: String,
    
    /// Target platform (e.g., "Arduino", "STM32", "ESP32", "RaspberryPi")
    pub platform: String,
    
    /// Programming language (e.g., "C", "C++", "Rust", "MicroPython")
    pub language: String,
    
    /// Communication protocol (e.g., "I2C", "SPI", "UART", "OneWire")
    pub protocol: String,
    
    /// Optional: Specific features to include in the driver
    pub features: Option<Vec<String>>,
    
    /// Optional: Include example usage code
    pub include_examples: Option<bool>,
}

pub struct DriverGenerator;

impl DriverGenerator {
    pub fn new() -> Self {
        Self
    }
    
    fn generate_driver_template(&self, args: &DriverGeneratorArgs) -> String {
        let component = &args.component;
        let platform = &args.platform;
        let protocol = &args.protocol;
        
        match args.language.as_str() {
            "C" | "C++" => self.generate_c_driver(component, platform, protocol),
            "Rust" => self.generate_rust_driver(component, platform, protocol),
            "MicroPython" => self.generate_micropython_driver(component, platform, protocol),
            _ => format!("Unsupported language: {}. Supported: C, C++, Rust, MicroPython", args.language)
        }
    }
    
    fn generate_c_driver(&self, component: &str, platform: &str, protocol: &str) -> String {
        format!(r#"/**
 * {} Driver for {}
 * Communication Protocol: {}
 * Generated by Wake - Hardware-First Coding Agent
 * 
 * Copyright (c) 2024 Wind
 */

#ifndef {}_H
#define {}_H

#include <stdint.h>
#include <stdbool.h>

// Hardware-specific includes
{}

// {} Register Definitions
{}

// {} Configuration Structure
typedef struct {{
    uint8_t address;      // Device I2C/SPI address
    uint8_t mode;         // Operating mode
    uint8_t sample_rate;  // Sampling rate configuration
    // Add more configuration parameters as needed
}} {}_config_t;

// {} Handle Structure
typedef struct {{
    {}_config_t config;
    void* interface;      // Hardware interface handle
    bool initialized;
}} {}_t;

// Function Prototypes
/**
 * Initialize the {} device
 * @param dev Device handle
 * @param config Configuration structure
 * @return 0 on success, error code otherwise
 */
int {}_init({}_t* dev, const {}_config_t* config);

/**
 * Read data from {}
 * @param dev Device handle
 * @param data Pointer to store read data
 * @return 0 on success, error code otherwise
 */
int {}_read_data({}_t* dev, void* data);

/**
 * Write data to {}
 * @param dev Device handle
 * @param reg Register address
 * @param value Value to write
 * @return 0 on success, error code otherwise
 */
int {}_write_register({}_t* dev, uint8_t reg, uint8_t value);

/**
 * Configure {} operating mode
 * @param dev Device handle
 * @param mode Operating mode
 * @return 0 on success, error code otherwise
 */
int {}_set_mode({}_t* dev, uint8_t mode);

/**
 * Perform self-test on {}
 * @param dev Device handle
 * @return true if self-test passes
 */
bool {}_self_test({}_t* dev);

/**
 * Reset {} to default state
 * @param dev Device handle
 * @return 0 on success, error code otherwise
 */
int {}_reset({}_t* dev);

/**
 * Get {} status
 * @param dev Device handle
 * @return Device status register value
 */
uint8_t {}_get_status({}_t* dev);

#endif // {}_H

/* Implementation file would go here with actual hardware communication code */
"#,
            component, platform, protocol,
            component.to_uppercase(), component.to_uppercase(),
            self.get_platform_includes(platform),
            component,
            self.generate_register_definitions(component, protocol),
            component,
            component,
            component,
            component,
            component,
            component,
            component.to_lowercase(), component, component,
            component,
            component.to_lowercase(), component,
            component,
            component.to_lowercase(), component,
            component,
            component.to_lowercase(), component,
            component,
            component.to_lowercase(), component,
            component,
            component.to_lowercase(), component,
            component,
            component.to_lowercase(), component,
            component.to_uppercase()
        )
    }
    
    fn generate_rust_driver(&self, component: &str, platform: &str, protocol: &str) -> String {
        format!(r#"//! {} Driver for {}
//! Communication Protocol: {}
//! Generated by Wake - Hardware-First Coding Agent
//! 
//! Copyright (c) 2024 Wind

#![no_std]

use embedded_hal::{{
    blocking::{},
    digital::v2::OutputPin,
}};

/// {} register definitions
pub mod registers {{
    pub const DEVICE_ID: u8 = 0x00;
    pub const CONFIG: u8 = 0x01;
    pub const STATUS: u8 = 0x02;
    pub const DATA_OUT: u8 = 0x03;
    // Add more registers as needed
}}

/// {} operating modes
#[derive(Clone, Copy, Debug)]
pub enum OperatingMode {{
    Sleep,
    Normal,
    HighPerformance,
    LowPower,
}}

/// {} configuration
#[derive(Clone, Copy, Debug)]
pub struct Config {{
    pub mode: OperatingMode,
    pub sample_rate: u16,
    pub enable_interrupt: bool,
}}

impl Default for Config {{
    fn default() -> Self {{
        Self {{
            mode: OperatingMode::Normal,
            sample_rate: 100,
            enable_interrupt: false,
        }}
    }}
}}

/// {} driver structure
pub struct {}<I, CS> {{
    interface: I,
    cs_pin: CS,
    config: Config,
}}

impl<I, CS, E> {}<I, CS>
where
    I: {},
    CS: OutputPin,
{{
    /// Create a new {} driver instance
    pub fn new(interface: I, cs_pin: CS) -> Result<Self, E> {{
        Ok(Self {{
            interface,
            cs_pin,
            config: Config::default(),
        }})
    }}
    
    /// Initialize the {} device
    pub fn init(&mut self) -> Result<(), E> {{
        // Reset device
        self.reset()?;
        
        // Configure device
        self.configure()?;
        
        // Verify device ID
        self.verify_device_id()?;
        
        Ok(())
    }}
    
    /// Read device ID
    pub fn read_device_id(&mut self) -> Result<u8, E> {{
        self.read_register(registers::DEVICE_ID)
    }}
    
    /// Read from a register
    fn read_register(&mut self, reg: u8) -> Result<u8, E> {{
        // Implementation depends on protocol
        todo!("Implement {} read for {}")
    }}
    
    /// Write to a register
    fn write_register(&mut self, reg: u8, value: u8) -> Result<(), E> {{
        // Implementation depends on protocol
        todo!("Implement {} write for {}")
    }}
    
    /// Reset the device
    pub fn reset(&mut self) -> Result<(), E> {{
        // Send reset command
        self.write_register(registers::CONFIG, 0x80)?;
        
        // Wait for reset to complete
        // Note: In real implementation, use proper delay
        
        Ok(())
    }}
    
    /// Configure the device
    pub fn configure(&mut self) -> Result<(), E> {{
        let config_value = match self.config.mode {{
            OperatingMode::Sleep => 0x00,
            OperatingMode::Normal => 0x01,
            OperatingMode::HighPerformance => 0x02,
            OperatingMode::LowPower => 0x03,
        }};
        
        self.write_register(registers::CONFIG, config_value)?;
        
        Ok(())
    }}
    
    /// Verify device ID
    fn verify_device_id(&mut self) -> Result<(), E> {{
        let id = self.read_device_id()?;
        // Check if ID matches expected value
        // This would be device-specific
        Ok(())
    }}
    
    /// Read sensor data
    pub fn read_data(&mut self) -> Result<u16, E> {{
        let high = self.read_register(registers::DATA_OUT)?;
        let low = self.read_register(registers::DATA_OUT + 1)?;
        Ok(((high as u16) << 8) | (low as u16))
    }}
}}
"#,
            component, platform, protocol,
            self.get_rust_hal_traits(protocol),
            component,
            component,
            component,
            component,
            component.to_lowercase(),
            component,
            self.get_rust_interface_trait(protocol),
            component,
            component,
            protocol, component,
            protocol, component
        )
    }
    
    fn generate_micropython_driver(&self, component: &str, _platform: &str, protocol: &str) -> String {
        format!(r#"""
{}Driver for MicroPython
Communication Protocol: {}
Generated by Wake - Hardware-First Coding Agent

Copyright (c) 2024 Wind
"""

from machine import {}
import time

class {}:
    """Driver for {} hardware component"""
    
    # Register definitions
    REG_DEVICE_ID = 0x00
    REG_CONFIG = 0x01
    REG_STATUS = 0x02
    REG_DATA = 0x03
    
    # Operating modes
    MODE_SLEEP = 0x00
    MODE_NORMAL = 0x01
    MODE_HIGH_PERF = 0x02
    MODE_LOW_POWER = 0x03
    
    def __init__(self, {}, address=0x68):
        """
        Initialize {} driver
        
        Args:
            {}: {} interface object
            address: Device address (default: 0x68)
        """
        self.{} = {}
        self.address = address
        self.initialized = False
        
    def init(self):
        """Initialize the {} device"""
        try:
            # Reset device
            self.reset()
            
            # Verify device ID
            device_id = self.read_register(self.REG_DEVICE_ID)
            print(f"Device ID: {{device_id:#x}}")
            
            # Configure device
            self.configure(self.MODE_NORMAL)
            
            self.initialized = True
            return True
            
        except Exception as e:
            print(f"Initialization failed: {{e}}")
            return False
    
    def reset(self):
        """Reset the {} device"""
        self.write_register(self.REG_CONFIG, 0x80)
        time.sleep_ms(10)  # Wait for reset
    
    def configure(self, mode):
        """
        Configure {} operating mode
        
        Args:
            mode: Operating mode constant
        """
        self.write_register(self.REG_CONFIG, mode)
    
    def read_register(self, reg):
        """
        Read from a register
        
        Args:
            reg: Register address
            
        Returns:
            Register value
        """
        {}
    
    def write_register(self, reg, value):
        """
        Write to a register
        
        Args:
            reg: Register address
            value: Value to write
        """
        {}
    
    def read_data(self):
        """
        Read sensor data
        
        Returns:
            Sensor data value
        """
        if not self.initialized:
            raise Exception("Device not initialized")
            
        high = self.read_register(self.REG_DATA)
        low = self.read_register(self.REG_DATA + 1)
        
        return (high << 8) | low
    
    def get_status(self):
        """
        Get device status
        
        Returns:
            Status register value
        """
        return self.read_register(self.REG_STATUS)
    
    def self_test(self):
        """
        Perform device self-test
        
        Returns:
            True if self-test passes
        """
        # Implement device-specific self-test
        status = self.get_status()
        return (status & 0x01) == 0

# Example usage
if __name__ == "__main__":
    # Initialize {} interface
    {} = {}
    
    # Create driver instance
    device = {}({})
    
    # Initialize device
    if device.init():
        print("Device initialized successfully")
        
        # Read data
        data = device.read_data()
        print(f"Data: {{data}}")
        
        # Check status
        status = device.get_status()
        print(f"Status: {{status:#x}}")
"#,
            component, protocol,
            self.get_micropython_interface(protocol),
            component,
            component,
            self.get_micropython_param(protocol),
            component,
            self.get_micropython_param(protocol), protocol,
            self.get_micropython_param(protocol), self.get_micropython_param(protocol),
            component,
            component,
            component,
            self.generate_micropython_read(protocol),
            self.generate_micropython_write(protocol),
            protocol,
            self.get_micropython_param(protocol), self.get_micropython_init(protocol),
            component, self.get_micropython_param(protocol)
        )
    }
    
    fn get_platform_includes(&self, platform: &str) -> &str {
        match platform {
            "Arduino" => "#include <Arduino.h>\n#include <Wire.h>",
            "STM32" => "#include \"stm32f4xx_hal.h\"",
            "ESP32" => "#include \"esp_system.h\"\n#include \"driver/i2c.h\"",
            "RaspberryPi" => "#include <wiringPi.h>\n#include <wiringPiI2C.h>",
            _ => "#include <stdint.h>"
        }
    }
    
    fn generate_register_definitions(&self, component: &str, protocol: &str) -> String {
        format!(r#"#define {}_REG_DEVICE_ID    0x00
#define {}_REG_CONFIG       0x01
#define {}_REG_STATUS       0x02
#define {}_REG_DATA_HIGH    0x03
#define {}_REG_DATA_LOW     0x04
#define {}_REG_CTRL         0x05
#define {}_REG_INT_ENABLE   0x06
#define {}_REG_INT_STATUS   0x07"#,
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase(),
            component.to_uppercase()
        )
    }
    
    fn get_rust_hal_traits(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "i2c::{Read, Write}",
            "SPI" => "spi::{Transfer, Write}",
            "UART" => "serial::{Read, Write}",
            _ => "delay::DelayMs"
        }
    }
    
    fn get_rust_interface_trait(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "embedded_hal::blocking::i2c::WriteRead",
            "SPI" => "embedded_hal::blocking::spi::Transfer<u8>",
            "UART" => "embedded_hal::serial::Write<u8>",
            _ => "embedded_hal::blocking::delay::DelayMs<u16>"
        }
    }
    
    fn get_micropython_interface(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "I2C",
            "SPI" => "SPI",
            "UART" => "UART",
            _ => "Pin"
        }
    }
    
    fn get_micropython_param(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "i2c",
            "SPI" => "spi",
            "UART" => "uart",
            _ => "pin"
        }
    }
    
    fn get_micropython_init(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "I2C(0, scl=Pin(22), sda=Pin(21), freq=400000)",
            "SPI" => "SPI(1, baudrate=1000000, polarity=0, phase=0)",
            "UART" => "UART(1, baudrate=115200)",
            _ => "Pin(2, Pin.OUT)"
        }
    }
    
    fn generate_micropython_read(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "# I2C read\n        return self.i2c.readfrom_mem(self.address, reg, 1)[0]",
            "SPI" => "# SPI read\n        self.spi.write(bytes([reg | 0x80]))  # Set read bit\n        return self.spi.read(1)[0]",
            "UART" => "# UART read\n        self.uart.write(bytes([reg]))\n        return self.uart.read(1)[0]",
            _ => "return 0  # Placeholder"
        }
    }
    
    fn generate_micropython_write(&self, protocol: &str) -> &str {
        match protocol {
            "I2C" => "# I2C write\n        self.i2c.writeto_mem(self.address, reg, bytes([value]))",
            "SPI" => "# SPI write\n        self.spi.write(bytes([reg, value]))",
            "UART" => "# UART write\n        self.uart.write(bytes([reg, value]))",
            _ => "pass  # Placeholder"
        }
    }
}

#[async_trait]
impl Tool for DriverGenerator {
    async fn run(&self, args: ToolArguments) -> Result<ToolResult, String> {
        let args: DriverGeneratorArgs = args.try_into()?;
        
        let driver_code = self.generate_driver_template(&args);
        
        let file_extension = match args.language.as_str() {
            "C" => "h",
            "C++" => "hpp",
            "Rust" => "rs",
            "MicroPython" => "py",
            _ => "txt"
        };
        
        let filename = format!("{}_{}_driver.{}", 
            args.component.to_lowercase(), 
            args.platform.to_lowercase(),
            file_extension
        );
        
        Ok(ToolResult::Success(format!(
            "Generated {} driver for {} on {} platform using {} protocol.\n\nDriver code saved as: {}\n\n{}",
            args.language,
            args.component,
            args.platform,
            args.protocol,
            filename,
            driver_code
        )))
    }
    
    fn name(&self) -> &str {
        "driver_generator"
    }
    
    fn description(&self) -> &str {
        "Generate hardware device drivers from component specifications. Supports multiple platforms (Arduino, STM32, ESP32, Raspberry Pi) and languages (C, C++, Rust, MicroPython)."
    }
}