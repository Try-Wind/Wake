use async_trait::async_trait;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use wake_macros::tool;

use crate::tools::types::{Error, Result, Tool};

#[tool(
    schema = "driver_generator",
    description = "Generates production-ready device drivers for various platforms (STM32, ESP32, Arduino, Raspberry Pi) from component specifications or datasheet analysis"
)]
pub struct DriverGenerator;

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct DriverGeneratorInput {
    /// Target platform (stm32, esp32, arduino, rpi, generic)
    pub platform: String,
    /// Component name and model
    pub component: String,
    /// Communication protocol (i2c, spi, uart, gpio)
    pub protocol: String,
    /// Programming language (c, cpp, rust, micropython)
    pub language: String,
    /// Additional configuration options
    pub config: Option<DriverConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct DriverConfig {
    /// I2C address if applicable
    pub i2c_address: Option<String>,
    /// SPI settings if applicable
    pub spi_config: Option<SpiConfig>,
    /// Include example usage code
    pub include_examples: bool,
    /// Include unit tests
    pub include_tests: bool,
    /// Use interrupts instead of polling
    pub use_interrupts: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct SpiConfig {
    pub clock_speed: String,
    pub mode: u8,
    pub bit_order: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct DriverGeneratorOutput {
    /// Generated driver code
    pub driver_code: String,
    /// Header file (for C/C++)
    pub header_code: Option<String>,
    /// Example usage code
    pub example_code: Option<String>,
    /// Test code
    pub test_code: Option<String>,
    /// Documentation
    pub documentation: String,
    /// Build instructions
    pub build_instructions: String,
}

#[async_trait]
impl Tool for DriverGenerator {
    type Input = DriverGeneratorInput;
    type Output = DriverGeneratorOutput;

    async fn run(&self, input: Self::Input) -> Result<Self::Output> {
        let driver_code = match input.language.as_str() {
            "c" => generate_c_driver(&input),
            "cpp" => generate_cpp_driver(&input),
            "rust" => generate_rust_driver(&input),
            "micropython" => generate_micropython_driver(&input),
            _ => return Err(Error::ToolExecutionError(format!("Unsupported language: {}", input.language))),
        };

        let header_code = if input.language == "c" || input.language == "cpp" {
            Some(generate_header(&input))
        } else {
            None
        };

        let example_code = if input.config.as_ref().map_or(true, |c| c.include_examples) {
            Some(generate_example(&input))
        } else {
            None
        };

        let test_code = if input.config.as_ref().map_or(false, |c| c.include_tests) {
            Some(generate_tests(&input))
        } else {
            None
        };

        Ok(DriverGeneratorOutput {
            driver_code,
            header_code,
            example_code,
            test_code,
            documentation: generate_documentation(&input),
            build_instructions: generate_build_instructions(&input),
        })
    }
}

fn generate_c_driver(input: &DriverGeneratorInput) -> String {
    format!(r#"/**
 * {} Driver for {}
 * Generated by Wake - Hardware-First Coding Agent
 * Protocol: {}
 */

#include "{}.h"
#include <stdint.h>
#include <stdbool.h>

// Initialize the device
int {}_init(void) {{
    // Initialize {} interface
    // Configure device registers
    return 0;
}}

// Read data from device
int {}_read(uint8_t reg, uint8_t *data, size_t len) {{
    // Implementation for {} protocol
    return 0;
}}

// Write data to device
int {}_write(uint8_t reg, uint8_t *data, size_t len) {{
    // Implementation for {} protocol
    return 0;
}}
"#, 
        input.component, input.platform, input.protocol,
        input.component.to_lowercase(),
        input.component.to_lowercase(), input.protocol,
        input.component.to_lowercase(), input.protocol,
        input.component.to_lowercase(), input.protocol
    )
}

fn generate_cpp_driver(input: &DriverGeneratorInput) -> String {
    format!(r#"/**
 * {} Driver for {}
 * Generated by Wake - Hardware-First Coding Agent
 * Protocol: {}
 */

#include "{}.h"

{}Driver::{}Driver() {{
    // Constructor
}}

bool {}Driver::begin() {{
    // Initialize {} interface
    return true;
}}

uint8_t {}Driver::readRegister(uint8_t reg) {{
    // Read from register
    return 0;
}}

void {}Driver::writeRegister(uint8_t reg, uint8_t value) {{
    // Write to register
}}
"#,
        input.component, input.platform, input.protocol,
        input.component.to_lowercase(),
        input.component, input.component,
        input.component, input.protocol,
        input.component,
        input.component
    )
}

fn generate_rust_driver(input: &DriverGeneratorInput) -> String {
    format!(r#"//! {} Driver for {}
//! Generated by Wake - Hardware-First Coding Agent
//! Protocol: {}

use embedded_hal::{{blocking::{}, delay::DelayMs}};

pub struct {}Driver<I> {{
    interface: I,
    address: u8,
}}

impl<I> {}Driver<I> 
where
    I: {} {{
    
    pub fn new(interface: I) -> Self {{
        Self {{
            interface,
            address: 0x68, // Default address
        }}
    }}

    pub fn init(&mut self) -> Result<(), Error> {{
        // Initialize device
        Ok(())
    }}

    pub fn read_register(&mut self, reg: u8) -> Result<u8, Error> {{
        // Read from register
        Ok(0)
    }}

    pub fn write_register(&mut self, reg: u8, value: u8) -> Result<(), Error> {{
        // Write to register
        Ok(())
    }}
}}

#[derive(Debug)]
pub enum Error {{
    Interface,
    InvalidData,
}}
"#,
        input.component, input.platform, input.protocol,
        get_rust_trait(&input.protocol),
        input.component,
        input.component,
        get_rust_trait(&input.protocol)
    )
}

fn generate_micropython_driver(input: &DriverGeneratorInput) -> String {
    format!(r#"""
{} Driver for {}
Generated by Wake - Hardware-First Coding Agent
Protocol: {}
"""

from machine import {}
import time

class {}Driver:
    def __init__(self, {}):
        self.interface = {}
        self.address = 0x68  # Default address
        
    def init(self):
        # Initialize device
        pass
        
    def read_register(self, reg):
        # Read from register
        return 0
        
    def write_register(self, reg, value):
        # Write to register
        pass
"#,
        input.component, input.platform, input.protocol,
        get_micropython_module(&input.protocol),
        input.component,
        get_micropython_params(&input.protocol),
        get_micropython_init(&input.protocol)
    )
}

fn generate_header(input: &DriverGeneratorInput) -> String {
    format!(r#"/**
 * {} Driver Header for {}
 * Generated by Wake - Hardware-First Coding Agent
 */

#ifndef {}_H
#define {}_H

#include <stdint.h>
#include <stdbool.h>

// Register definitions
#define {}_REG_CONFIG    0x00
#define {}_REG_STATUS    0x01
#define {}_REG_DATA      0x02

// Function prototypes
int {}_init(void);
int {}_read(uint8_t reg, uint8_t *data, size_t len);
int {}_write(uint8_t reg, uint8_t *data, size_t len);

#endif // {}_H
"#,
        input.component, input.platform,
        input.component.to_uppercase(),
        input.component.to_uppercase(),
        input.component.to_uppercase(),
        input.component.to_uppercase(),
        input.component.to_uppercase(),
        input.component.to_lowercase(),
        input.component.to_lowercase(),
        input.component.to_lowercase(),
        input.component.to_uppercase()
    )
}

fn generate_example(input: &DriverGeneratorInput) -> String {
    format!("// Example usage for {} driver on {}", input.component, input.platform)
}

fn generate_tests(input: &DriverGeneratorInput) -> String {
    format!("// Test suite for {} driver", input.component)
}

fn generate_documentation(input: &DriverGeneratorInput) -> String {
    format!(r#"# {} Driver Documentation

## Overview
This driver provides support for the {} on the {} platform using {} protocol.

## Installation
Follow the build instructions below to integrate this driver into your project.

## API Reference
- `init()`: Initialize the device
- `read()`: Read data from the device
- `write()`: Write data to the device

## Example Usage
See the example code for typical usage patterns.

Generated by Wake - Hardware-First Coding Agent by Wind
"#, input.component, input.component, input.platform, input.protocol)
}

fn generate_build_instructions(input: &DriverGeneratorInput) -> String {
    match input.language.as_str() {
        "c" | "cpp" => format!("Add {}.c and {}.h to your project makefile", 
            input.component.to_lowercase(), input.component.to_lowercase()),
        "rust" => "Add to Cargo.toml dependencies".to_string(),
        "micropython" => format!("Copy {}.py to your device", input.component.to_lowercase()),
        _ => "See documentation for build instructions".to_string(),
    }
}

fn get_rust_trait(protocol: &str) -> &str {
    match protocol {
        "i2c" => "i2c::Write + i2c::Read",
        "spi" => "spi::Transfer<u8>",
        _ => "// Add appropriate trait"
    }
}

fn get_micropython_module(protocol: &str) -> &str {
    match protocol {
        "i2c" => "I2C",
        "spi" => "SPI",
        "uart" => "UART",
        _ => "Pin"
    }
}

fn get_micropython_params(protocol: &str) -> &str {
    match protocol {
        "i2c" => "i2c, addr=0x68",
        "spi" => "spi, cs",
        _ => "pin"
    }
}

fn get_micropython_init(protocol: &str) -> &str {
    match protocol {
        "i2c" => "I2C(i2c, addr)",
        "spi" => "SPI(spi, cs)",
        _ => "Pin(pin)"
    }
}